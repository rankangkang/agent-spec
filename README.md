# Agent Spec TODO

此目录存储开发不同阶段和各种任务的可复用提示词，并记录了在其他项目中复用这些 prompts 与 rules 的推荐流程，方便后续查阅。

## 1. 目录与角色概览

本仓库中与 AI 行为相关的几个核心目录约定如下（以当前 `agent-spec` 仓库为例）：

- `rules/`：存放通用规则，包括个人规则（如 `personal.md`）、项目级规则模板（如 `project-rules.md`）、技术栈规则（如 TypeScript、React 等）。
- `prompts/`（当前目录）：存放可复用的提示词模板，包括系统级提示词、模式（mode）提示词等。
  - `prompts/system/`：系统级提示词，如 `plan-mode.md`、`ears-generator.md` 等。
- `skills/`（可选）：封装可复用的能力/工具调用逻辑。
- `templates/`（可选）：存放可复用的输出模版，如需求说明模版、接口文档模版等。

> 设计意图：将“规则（rules）”与“提示词（prompts）”解耦，前者更多是行为约束与规范，后者是具体任务/模式的启动模版。

## 2. 跨项目复用总流程（推荐做法）

为了在多个项目中复用同一套 rules 与 prompts，推荐将当前 `agent-spec` 仓库作为“规范子模块”挂载到每个业务仓库中，并约定统一的加载目录与优先级。

### 2.1 在业务项目中挂载 `.agent-spec/`

1. 在业务项目根目录添加本仓库为 Git 子模块（示例命令）：
   - `git submodule add <agent-spec-repo-url> .agent-spec`
2. 约定：如果项目根目录存在 `.agent-spec/`，AI 助手就从该目录中加载通用的 rules 与 prompts。
3. 推荐目录结构示例：

   ```text
   your-project/
     .agent-spec/           # 通用层（当前这个仓库，作为子模块使用）
       rules/
       prompts/
       skills/
       templates/
     .project-agent-rules/  # 项目层（业务仓库自身定义，用于覆盖和扩展）
       project-rules.md
       overrides/
         react-rules.override.md
     src/
     package.json
     ...
   ```

### 2.2 加载顺序与优先级建议

在 AI 启动或初始化时，建议采用如下优先级链路加载规则与提示词：

1. **系统内置规则**（平台级约束，最高优先级）。
2. **通用层（本仓库）**：来自 `.agent-spec/` 的内容，例如：
   - `.agent-spec/rules/personal.md`
   - `.agent-spec/rules/ts-rules.md`、`.agent-spec/rules/react-rules.md`
   - `.agent-spec/prompts/system/plan-mode.md`
   - `.agent-spec/prompts/system/ears-generator.md`
3. **项目层（业务仓库自身）**：来自 `.project-agent-rules/`（名称可按约定调整），例如：
   - `.project-agent-rules/project-rules.md`
   - `.project-agent-rules/overrides/*`（用于对通用规则做覆盖/补充）

> 推荐行为：项目层只写与当前业务密切相关的部分，不复制通用规则内容，避免未来同步升级时产生大量重复维护。

### 2.3 在新项目中的快速使用清单

在一个新业务项目中复用当前规则与提示词时，可以按如下步骤执行：

1. 在项目根目录挂载规范子模块：
   - `git submodule add <agent-spec-repo-url> .agent-spec`
2. 配置 AI 启动逻辑，使其在初始化时：
   - 如果存在 `.agent-spec/rules/personal.md`，作为“个人/通用行为”基础层规则加载。
   - 如果存在 `.agent-spec/rules/*.md`，按需要加载技术栈规则（如 TypeScript 规则、React 规则等）。
   - 如果存在 `.agent-spec/prompts/system/plan-mode.md`，注册为 Plan Mode 模式提示词。
   - 如果存在 `.agent-spec/prompts/system/ears-generator.md`，注册为 EARS 需求生成提示词。
3. 在业务项目中新增 `.project-agent-rules/`（或约定名称的目录），编写项目专属规则，如：
   - 目录结构约定
   - 特定 API 命名约束
   - 项目特有的模块划分/边界
4. 在运行时使用“系统 > 通用层 > 项目层”的优先级组合规则与提示词。

## 3. 工作流程一：Plan Mode（规划模式）

Plan Mode 是一个三阶段的工作模式，用于在复杂需求下先规划再执行，降低实施风险。对应的系统提示词位于：

- `prompts/system/plan-mode.md`

### 3.1 三个阶段概览

1. **需求澄清与目标对齐**
   - 明确用户的目标、约束条件、输入输出格式。
   - 如果信息不足，通过提问或标记 `TBD` 的方式显式暴露不确定性。
2. **实施方案与里程碑规划**
   - 拆分成若干小步骤/里程碑，每个步骤尽量是可独立验证的增量。
   - 约定每个里程碑的输入、产出与验收标准。
   - 按需给出目录结构、模块划分建议，并对关键技术点做简要评估。
3. **逐步执行并回顾**
   - 按规划顺序逐步执行，每一步都可单独审阅和回滚。
   - 每完成一个关键步骤，简要记录本步变更与影响。
   - 根据中途反馈调整后续计划。

### 3.2 命名与隐藏路径约定

- `feature_name` 建议使用 **kebab-case**（例如：`user-auth-flow`），便于在不同语言/环境中统一引用。
- 对于不适合暴露的路径/内部实现细节，在对话中以“占位符”方式描述，例如：
  - `src/<feature_name>/components/...`
  - `internal/<feature_name>/domain/...`
- 在真正写代码时，再根据项目实际目录结构展开这些占位符。

### 3.3 进入与退出 Plan Mode 的时机

- **适合进入 Plan Mode 的场景**：
  - 需求较复杂、涉及多模块或多服务的改动。
  - 需要多次往复才能达成共识的功能设计。
- **退出 Plan Mode 的时机**：
  - 主要里程碑已经完成，后续只需小范围迭代。
  - 用户明确表示不再需要继续以 Plan Mode 的形式推进。

在实现层面，可以通过在系统提示词中显式标记“当前处于 Plan Mode / 已退出 Plan Mode”的方式，提醒模型使用不同的工作风格。

## 4. 工作流程二：EARS 需求分析模式

EARS（Easy Approach to Requirements Syntax）是一种结构化需求表达方式，通过统一句式来提升需求的可读性与可验证性。对应的系统提示词位于：

- `prompts/system/ears-generator.md`

### 4.1 核心句式

典型的 EARS 句式可以概括为：

> 当【触发条件】发生时，系统 **必须/应该** 【执行的行为】，并满足【约束/结果】。

在文档中常见的变体有：

- 事件驱动型：当 X 发生时，系统必须 Y。
- 状态驱动型：在状态 S 下，系统必须 Y。
- 用户交互型：当用户执行 U 时，系统必须 Y。
- 兜底/错误处理型：当发生 E 时，系统必须记录/告警/回退。

### 4.2 信息缺失与不确定性的标记

- 当信息不足时，不抹平不确定性，而是显式标记，例如：
  - `TBD：登录失败时的重试次数`。
  - `待确认：第三方支付回调超时时间`。
- 推荐在同一 EARS 文档或输出中增加一个“待确认项清单”，方便后续与业务/产品对齐。

### 4.3 多模块场景下的拆分建议

在多模块或跨系统场景中，建议按照“角色/系统边界”拆分 EARS 需求：

- 面向前端的需求：聚焦交互行为、展示与输入校验。
- 面向后端的需求：聚焦业务规则、数据一致性与接口契约。
- 面向第三方系统的需求：聚焦集成协议、错误处理与重试策略。

每个角色/模块下，可以进一步按照“触发器”划分需求条目，例如：

- 用户点击“提交订单”按钮时...
- 支付渠道返回成功回调时...
- 定时任务每天 00:00 触发时...

## 5. 如何新增或扩展 Prompts

当需要为新的模式或任务增加可复用提示词时，建议遵循以下步骤：

1. **选择合适的目录与命名**：
   - 系统级模式/行为：放在 `prompts/system/`，例如：`review-mode.md`、`refactor-mode.md`。
   - 任务级模版：可以根据需要在 `prompts/` 下增加子目录，如 `prompts/tasks/`。
2. **保持结构清晰**：
   - 开头明确说明：适用场景、输入输出要求、与其他模式的关系。
   - 结合本仓库已有的 `plan-mode.md`、`ears-generator.md` 的结构风格，保持一致性。
3. **避免重复**：
   - 尽量引用已有规则（如 `rules/personal.md` 中的语言与行为约束），不要在 prompt 中重复相同规则。
4. **为跨项目复用设计**：
   - 避免写入只对单一项目有效的路径或业务名，如果确有需要，则应放到项目层规则/提示词中。

## 6. 版本管理与升级建议

为了在多个项目中安全地复用与升级本仓库的规则和提示词，建议：

- 为 `agent-spec` 仓库打 **tag**（如 `v1.0.0`、`v1.1.0`），每次规则或提示词发生不兼容变更时更新版本号。
- 在业务项目中，将 `.agent-spec` 子模块指向一个明确的 tag 或 commit，而不是默认跟随 `main` 分支。
- 在升级时：
  1. 在单一项目中先更新 `.agent-spec` 子模块到新版本。
  2. 查看 diff，重点关注 `rules/` 与 `prompts/system/` 下的变更。
  3. 确认对当前项目无破坏后再在其他项目中滚动升级。

通过以上约定，可以将当前仓库中的 rules 与 prompts 作为一个可持续演进的“统一规范层”，在多个项目中方便快捷地复用，同时保留每个项目的个性化扩展空间。

## 7. 附录：规则与提示词优化的思路与实施细节

本附录用于记录本仓库当前这版 rules 与 prompts 的设计思路，以及本次优化和实现过程中的关键决策，方便后续回顾和在其他项目中复用或调整。

### 7.1 初始现状理解

在本次优化之前，整体情况大致如下：

- `rules/personal.md`
  - 已经包含了语言偏好（中文回答、TypeScript 编码）、开发流程（先伪代码后实现）、代码质量要求（DRY、高可读性）等内容。
  - 但规则是“平铺式”的，缺少分组和优先级说明，一些内容存在语义重复（如多处强调“保持简洁”“避免冗长”）。
- `rules/project-rules.md`
  - 明确了项目模块化组织、命名规范等，但“何时建立/退化目录”“测试和样式如何组织”等决策点不够清晰。
  - 前后端规则混杂在一起，尚未明确跨端命名差异与适用范围。
- `prompts/system/plan-mode.md`
  - 已有大致的三阶段思想（分析 → 规划 → 执行），但缺乏：
    - 如何进入/退出 Plan Mode 的时机说明。
    - `feature_name`、路径占位符等命名层面的规范。
    - 对失败/回退场景的指导。
- `prompts/system/ears-generator.md`
  - 提供了结构化模版，但“只输出涉及部分”与“保持模板完整结构”的要求存在潜在冲突。
  - 技术考量部分较重，可能导致输出过于冗长；缺少对“信息缺失”“多模块拆分”的明确约束。

整体问题可以概括为：**内容方向正确，但在结构化、优先级、可复用性和落地指导上还有提升空间。**

### 7.2 优化 `rules/personal.md` 的思路

对个人规则的优化遵循以下原则：

- **分组与层次化**：
  - 将规则按主题拆分为：语言与输出偏好、工作流程（先伪代码后实现等）、质量与可维护性（DRY、可读性）、环境推理等小节。
  - 每个小节内按“先高层行为，再细节偏好”的顺序排列，方便快速浏览。
- **去重与合并**：
  - 将语义接近的条目合并，例如多处强调“简洁”“不要冗长描述”的规则合并为一条更清晰的说明。
  - 保留全部意图，但减少文字冗余，降低理解成本。
- **明确优先级**：
  - 在开头增加“适用范围与优先级”说明：当与系统/项目规则冲突时，以系统/项目规则为准；个人规则主要补充“风格偏好”和“工作习惯”。
- **保持与用户偏好对齐**：
  - 严格保留用户指定的行为，如“先写伪代码再写实现”“优先命名导出”“不主动生成测试/多余文档”等，不做弱化，只做结构化和澄清。

### 7.3 优化 `rules/project-rules.md` 的思路

项目级规则的调整重点在“可扩展的目录规范”和“跨技术栈的一致性”：

- **目录扩展/退化策略**：
  - 明确何时应该从“单文件”扩展为“目录”（例如：同类资源达到一定数量、复杂度明显提升时）。
  - 同时给出“目录退化”条件：当某目录下只剩 1～2 个文件且不会继续扩展时，可以合并回上层，避免空洞结构。
- **前后端命名一致性**：
  - 明确前端、后端、脚本等的命名风格（如目录使用 kebab-case，TS 文件使用 camelCase 命名导出），并说明适用范围，避免混乱。
- **测试、样式、资源组织**：
  - 虽不在本轮完全展开，但在规则中预留位置和示例，提示：
    - 测试文件与被测文件的邻近放置策略。
    - 样式（CSS-in-JS 或独立样式文件）的推荐组织方式。
    - 静态资源（images/fonts 等）的集中存放约定。
- **与 prompts 的协同**：
  - 保持项目规则更多关注“代码与目录结构”，而将“工作模式/流程”（如 Plan Mode）放在 `prompts/system/` 中，避免概念混淆。

### 7.4 优化 `prompts/system/plan-mode.md` 的思路

Plan Mode 被设计为一个明确的“三阶段工作模式”，本轮优化主要是让其变得：**可预期、可进入/退出、可回滚**。

主要思路：

- **强化三阶段结构**：
  - 阶段一：需求澄清与目标对齐。
  - 阶段二：实施方案与里程碑规划（每个里程碑都可以独立验证）。
  - 阶段三：逐步执行并在每步结束时进行简要回顾。
- **命名与路径规范**：
  - 引入 `feature_name` 概念，并建议使用 kebab-case（例如 `user-auth-flow`），方便在不同代码环境统一引用。
  - 对内部路径使用占位符（如 `src/<feature_name>/components/...`），在具体项目中再展开为真实路径，避免将特定项目路径写死进通用 prompt。
- **进入/退出与回退策略**：
  - 在提示词中强调：
    - 适合进入 Plan Mode 的场景（复杂需求、多模块改动等）。
    - 退出条件（主要里程碑完成或用户明确要求关闭 Plan Mode）。
  - 对于用户拒绝某个里程碑方案或中途调整需求时，建议“回退到需求澄清阶段”重新梳理，而不是在原计划上硬补丁。

### 7.5 优化 `prompts/system/ears-generator.md` 的思路

EARS 模式的优化专注在：**输出聚焦、可验证性强、对信息缺失友好**。

主要调整思路：

- **解决模板完整性与“只输出相关部分”的矛盾**：
  - 明确：以“只输出与当前需求相关的部分”为主，但保留必要的结构感（如按模块/场景分段）。
  - 避免为了“模板完整”而输出大量空内容或与当前问题无关的段落。
- **信息缺失的显式标记**：
  - 引入 `TBD`/`待确认` 的统一标记方式，用于记录：
    - 未提供但关键的参数（例如重试次数、超时配置）。
    - 需业务/产品进一步确认的流程分支。
  - 鼓励在文末集中列出“待确认项清单”，作为后续对齐的 checklist。
- **多模块/多角色拆分**：
  - 建议按角色/系统边界拆分需求：前端、后端、外部系统（第三方）等。
  - 在每个模块内部再按“触发器”划分 EARS 需求（用户点击、定时任务触发、外部回调等）。
- **控制技术考量的复杂度**：
  - 将“技术考量”从堆砌细节转为“列出关键接口、关键组件、关键约束”三类信息，保持简洁且有用。

### 7.6 跨项目复用方案的设计与取舍

围绕“如何在其他项目中方便复用这些 rules 与 prompts”，考虑和取舍过程大致如下：

- **候选方案**：
  1. 直接复制一份规则与提示词到每个项目。
  2. 将规则与提示词打包为 NPM 包或类似依赖。
  3. 使用 Git 子模块的方式，在项目中引入统一的 `.agent-spec/` 目录。
- **取舍逻辑**：
  - 方案 1（复制）：初期简单，但后期难以维护多份副本，更新成本高，容易出现版本漂移和不一致。
  - 方案 2（NPM 包）：适合纯代码依赖，但对于“规则 + 文档 + 各类提示词”这种混合内容来说，打包发布/更新流程相对繁琐，而且对于非 Node 项目不友好。
  - 方案 3（Git 子模块）：
    - 可以在任意技术栈的项目中使用（语言无关）。
    - 支持按 tag/commit 锁定版本，方便跨项目同步升级。
    - 目录结构简单、直观（`.agent-spec/` 即规范层）。
- **最终选择**：
  - 推荐采用 **子模块 + 项目层覆盖** 的分层结构：
    - 通用层：`.agent-spec/`（当前仓库），提供通用 rules 和 prompts。
    - 项目层：`.project-agent-rules/`（或类似目录），由业务项目自行维护，用于对通用规则做少量覆盖和补充。
  - 并在本仓库的 `prompts/README.md` 中记录了这一方案的目录结构和加载优先级，方便下一次复用时参考。

### 7.7 后续演进建议

在未来继续演进这些 rules 和 prompts 时，可以参考以下原则：

- **保持分层清晰**：
  - 通用层只包含跨项目稳定的规则与提示词；项目层负责具体业务和技术栈的特殊要求。
- **统一风格与术语**：
  - 当新增规则或提示词时，尽量复用已有术语（例如 Plan Mode、EARS、feature_name 等），避免不同文件中出现语义接近但名称不同的概念。
- **用版本管理控制变更范围**：
  - 通过 tag 管理本仓库版本（`v1.x`、`v2.x`），在业务项目中按需升级，降低破坏性变更的风险。
- **为“怎么做”留记录**：
  - 类似本节的“思路与实施细节”记录，建议在未来有较大重构时继续扩写，用简洁的文字说明“为什么要这么改”，以便自己或团队在半年后仍然看得懂。

通过以上记录，后续在新项目中如果遇到类似需求（例如：需要调整规则、扩展新的工作模式 prompt、重新设计复用机制），可以先翻阅本附录了解当初的设计思路，再决定是复用、微调还是重构。


## TODO

- [x] git worktree 工作流 SKILL（`skills/git-worktree-workflow/`）
- [ ] 